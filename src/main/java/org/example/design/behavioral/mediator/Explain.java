package org.example.design.behavioral.mediator;

/**
 *  中介者模式是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。该模式会限制对象之间的直接交互，迫使它们通过一个中介者对象进行合作。
 *
 *  例如，每个人必须记住他（她）所有朋友的电话；而且，朋友中如果有人的电话修改了，他（她）必须让其他所有的朋友一起修改，这叫作“牵一发而动全身”，非常复杂。
 *
 *  如图：./picture/mediator/mediator.png
 *
 *  常见应用：spring的IOC容器的思想就是简化版中介模式！ 在以往没有spring的时候，我们通常会在控制层引用大量的service，同时各个类中都有重复的引用；
 *          springIOC的出现，让所有需要重复使用的类统统注册进IOC容器中，由IOC统一分发给需要的类！不过IOC容器只是负责注册和引用分发，并不负责业务逻辑的处理，所以是简化版的中介模式
 *
 *  优点：
 *      1、类之间各司其职，符合迪米特法则。
 *      2、降低了对象之间的耦合性，使得对象易于独立地被复用。
 *      3、将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。
 *
 *  缺点：
 *      1、中介者模式将原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖关系。当同事类越多时，中介者就会越臃肿，变得复杂且难以维护。
 *
 *
 *  中介者模式包含以下主要角色。
 *      1、抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。
 *      2、具体中介者（Concrete Mediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。
 *      3、抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。
 *      4、具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。
 *
 *  类图: ./picture/mediator/mediator2.png
 *
 *  中介者模式经常有很多变体，个人理解大致归为二类：建议按顺序观看
 *      1、无中介者模式实现-[参考require包]
 *      2、简化版中介者模式-[参考simple包]
 *      3、传统中介者模式实现-[参考complete包]
 *
 *  简化版中介者模式使用场景：推荐
 *      1、类似Spring IOC使用场景，将所有引用存储至中介者类，业务类所需引用均从中介者类获取即可-[实战中常用]
 *
 *  传统版中介者模式使用场景：分场景使用
 *      1、将所有引用注册进中介者类中，并由中介者模式管理所有分发逻辑处理-[实战中并不建议这样做]
 *
 * Author: GL
 * Date: 2021-11-10
 */
public class Explain {
}
