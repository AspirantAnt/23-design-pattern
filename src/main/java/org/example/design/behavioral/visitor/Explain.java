package org.example.design.behavioral.visitor;

/**
 *  访问者模式：最复杂的设计模式，并且使用频率不高，大多情况下，你不需要使用访问者模式，但是一旦需要使用它时，那就真的需要使用了。
 *
 *  一、访问者模式的使用场景：
 *      1、对象结构比较稳定，但经常需要在此对象结构上定义新的操作。
 *      2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。
 *
 *  二、访问者模式的UML类图：picture/vistor/vistor.png
 *
 *  三、角色介绍:
 *
 *      Visitor：接口或者抽象类，定义了对每个 Element 访问的行为，它的参数就是被访问的元素，它的方法个数理论上与元素的个数是一样的，因此，访问者模式要求元素的类型要稳定，
 *               如果经常添加、移除元素类，必然会导致频繁地修改Visitor 接口，如果出现这种情况，则说明不适合使用访问者模式。
 *
 *      ConcreteVisitor：具体的访问者，它需要给出对每一个元素类访问时所产生的具体行为。
 *      Element：元素接口或者抽象类，它定义了一个接受访问者（accept）的方法，其意义是指每一个元素都要可以被访问者访问。
 *      ElementA、ElementB：具体的元素类，它提供接受访问的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。
 *      ObjectStructure：定义当中所提到的对象结构，对象结构是一个抽象表述，它内部管理了元素集合，并且可以迭代这些元素提供访问者访问。
 *
 *
 *  四、访问者模式的简单示例：
 *
 *      年底，CEO和CTO开始评定员工一年的工作绩效，员工分为工程师和经理，CTO关注工程师的代码量、经理的新产品数量；CEO关注的是工程师的KPI和经理的KPI以及新产品数量。
 *      由于CEO和CTO对于不同员工的关注点是不一样的，这就需要对不同员工类型进行不同的处理。访问者模式此时可以派上用场了。
 *
 *  五、实现方式：
 *      1、simple.one 中主要描述了java的静态分派和动态单分派的特点案例
 *      2、simple.two 中主要使用了策略模式来实现上述需求，以此引出访问者模式的好处
 *      3、complete   真正使用策略模式
 *
 * Author: GL
 * Date: 2021-11-22
 */
public class Explain {
}
